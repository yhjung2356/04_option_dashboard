# 페이지 상태 전달 가이드

## 개요
Spring Boot 애플리케이션에서 서버와 클라이언트 간 페이지 상태를 전달하는 3가지 주요 방법을 구현했습니다.

---

## 1. 서버 → 클라이언트: Model을 통한 초기 데이터 전달

### 서버 측 (DashboardController.java)
```java
@GetMapping("/")
public String index(Model model) {
    // 페이지 초기 상태를 Model을 통해 전달
    model.addAttribute("dataSource", dataSource);
    model.addAttribute("demoMode", demoMode);
    model.addAttribute("marketHoursEnabled", marketHoursEnabled);
    model.addAttribute("currentTimestamp", System.currentTimeMillis());
    
    return "dashboard";
}
```

### 클라이언트 측 (dashboard.html)
Thymeleaf inline JavaScript를 사용하여 서버 데이터를 JavaScript 변수로 전달:

```html
<script th:inline="javascript">
    const PAGE_STATE = {
        dataSource: /*[[${dataSource}]]*/ 'KIS',
        demoMode: /*[[${demoMode}]]*/ false,
        marketHoursEnabled: /*[[${marketHoursEnabled}]]*/ true,
        initialTimestamp: /*[[${currentTimestamp}]]*/ 0
    };
    
    window.dashboardState = {
        ...PAGE_STATE,
        isConnected: false,
        lastUpdate: null,
        currentView: 'overview'
    };
</script>
```

**장점:**
- 페이지 로드 시 즉시 사용 가능
- 추가 HTTP 요청 불필요
- SEO 친화적

**단점:**
- 페이지 로드 시점의 정적 데이터만 전달 가능

---

## 2. 클라이언트 → 서버: REST API를 통한 상태 조회

### 서버 측 (MarketDataController.java)
시스템 상태를 조회하는 REST API 엔드포인트:

```java
@GetMapping("/state")
public ResponseEntity<Map<String, Object>> getSystemState() {
    Map<String, Object> state = new HashMap<>();
    state.put("dataSource", dataSource);
    state.put("demoMode", demoMode);
    state.put("marketHoursEnabled", marketHoursEnabled);
    state.put("timestamp", System.currentTimeMillis());
    state.put("serverTime", new java.util.Date());
    return ResponseEntity.ok(state);
}
```

### 클라이언트 측 (dashboard.js)
JavaScript에서 API 호출:

```javascript
// StateManager를 사용한 상태 조회
const state = await StateManager.fetchSystemState();

// 또는 직접 fetch 사용
const response = await fetch('/api/market/state');
const state = await response.json();
console.log(state);
```

**API 엔드포인트:** `GET /api/market/state`

**응답 예시:**
```json
{
    "dataSource": "KIS",
    "demoMode": false,
    "marketHoursEnabled": true,
    "timestamp": 1734700000000,
    "serverTime": "2024-12-20T10:00:00.000+00:00"
}
```

**장점:**
- 실시간 최신 데이터 조회 가능
- 필요할 때만 요청하여 리소스 절약
- 서버 상태 변경 시 동적으로 반영

**단점:**
- 네트워크 요청 필요
- 비동기 처리 필요

---

## 3. JavaScript 상태 관리 시스템

### StateManager 객체 사용법

프로젝트에 포함된 `StateManager` 객체로 클라이언트 측 상태를 관리할 수 있습니다.

#### 기본 사용법

```javascript
// 1. 전체 상태 조회
const state = StateManager.getState();
console.log(state);

// 2. 특정 값 조회
const dataSource = StateManager.get('dataSource');
const demoMode = StateManager.get('demoMode');

// 3. 값 설정
StateManager.set('currentView', 'optionChain');
StateManager.set('isConnected', true);

// 4. 서버에서 최신 상태 가져오기
await StateManager.fetchSystemState();

// 5. 상태 업데이트
StateManager.updateState({
    lastUpdate: new Date(),
    marketStatus: 'open'
});
```

#### 로컬스토리지 활용

```javascript
// 자동 저장 (set 호출 시 자동)
StateManager.set('userPreference', 'dark-mode');

// 페이지 로드 시 복원
StateManager.restoreFromLocalStorage();
```

#### 상태 변경 이벤트 리스닝

```javascript
// 상태 변경 감지
window.addEventListener('stateChanged', function(event) {
    console.log('상태가 변경되었습니다:', event.detail);
    
    // 상태에 따른 UI 업데이트
    if (event.detail.dataSource === 'SAMPLE') {
        showDemoWarning();
    }
});
```

---

## 4. WebSocket을 통한 실시간 상태 전달

### 현재 구현된 WebSocket 연결

```javascript
function connect() {
    const socket = new SockJS('/ws');
    stompClient = Stomp.over(socket);
    
    stompClient.connect({}, function(frame) {
        console.log('Connected: ' + frame);
        StateManager.set('isConnected', true);
        
        // 시장 데이터 구독
        stompClient.subscribe('/topic/market-overview', function(message) {
            const data = JSON.parse(message.body);
            updateMarketOverview(data);
        });
    });
}
```

**WebSocket 엔드포인트:** `ws://localhost:8080/ws`

**구독 토픽:**
- `/topic/market-overview` - 시장 전체 현황 업데이트

**장점:**
- 실시간 양방향 통신
- 서버 푸시 가능
- 낮은 지연시간

---

## 5. 실제 사용 예제

### 예제 1: 페이지 로드 시 초기화

```javascript
document.addEventListener('DOMContentLoaded', async function() {
    // 1. 저장된 사용자 설정 복원
    StateManager.restoreFromLocalStorage();
    
    // 2. 서버에서 최신 상태 가져오기
    await StateManager.fetchSystemState();
    
    // 3. 상태에 따른 UI 초기화
    const state = StateManager.getState();
    
    if (state.demoMode) {
        showDemoBanner();
    }
    
    if (state.dataSource === 'SAMPLE') {
        loadSampleData();
    } else {
        connectToRealAPI();
    }
    
    // 4. WebSocket 연결
    connect();
});
```

### 예제 2: 사용자 설정 저장

```javascript
// 사용자가 설정 변경
function onUserSettingChanged(setting, value) {
    StateManager.set(setting, value);
    // 자동으로 localStorage에 저장됨
    
    // UI 업데이트
    applyUserSetting(setting, value);
}
```

### 예제 3: 조건부 기능 활성화

```javascript
// 시장 시간 체크 기능
function updateMarketStatus() {
    const enabled = StateManager.get('marketHoursEnabled');
    
    if (!enabled) {
        // 시장 시간 체크 비활성화
        return;
    }
    
    // 시장 시간 체크 로직 실행
    checkMarketHours();
}
```

### 예제 4: 데이터 소스 전환

```javascript
async function switchDataSource(newSource) {
    // 서버에 변경 요청 (구현 필요)
    await fetch('/api/settings/data-source', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ dataSource: newSource })
    });
    
    // 로컬 상태 업데이트
    StateManager.set('dataSource', newSource);
    
    // 데이터 리로드
    location.reload();
}
```

---

## 6. 상태 구조

### window.dashboardState 객체

```javascript
{
    // 서버에서 전달받은 설정
    dataSource: 'KIS',              // 데이터 소스 (KIS/KRX/SAMPLE)
    demoMode: false,                // 데모 모드 여부
    marketHoursEnabled: true,       // 시장 시간 체크 활성화
    initialTimestamp: 1734700000,   // 페이지 로드 시각
    
    // 클라이언트에서 관리하는 상태
    isConnected: false,             // WebSocket 연결 상태
    lastUpdate: null,               // 마지막 데이터 업데이트 시각
    currentView: 'overview',        // 현재 보고 있는 뷰
    
    // 사용자 설정 (추가 가능)
    theme: 'light',
    refreshInterval: 2000,
    notifications: true
}
```

---

## 7. 베스트 프랙티스

### ✅ 권장사항

1. **초기 로드 최적화**
   - 중요한 설정은 Model을 통해 전달 (추가 요청 불필요)
   - 동적 데이터는 API로 조회

2. **상태 관리 일관성**
   - StateManager를 통해 중앙 집중식 관리
   - 직접 `window.dashboardState` 수정 지양

3. **에러 처리**
   ```javascript
   try {
       const state = await StateManager.fetchSystemState();
       if (!state) {
           // 폴백 로직
           useFallbackState();
       }
   } catch (error) {
       console.error('상태 조회 실패:', error);
       showErrorMessage();
   }
   ```

4. **보안**
   - 민감한 정보는 상태에 포함하지 않음
   - API 키, 비밀번호 등은 서버에서만 관리

### ❌ 피해야 할 사항

1. 너무 많은 데이터를 페이지 로드 시 전달
2. 상태를 여러 곳에서 직접 수정
3. localStorage 과다 사용 (용량 제한 주의)
4. 동기적 API 호출 (async/await 사용)

---

## 8. 확장 가능성

### 추가 구현 가능 기능

1. **상태 동기화**
   ```javascript
   // 여러 탭 간 상태 동기화
   window.addEventListener('storage', function(e) {
       if (e.key === 'dashboardState') {
           StateManager.restoreFromLocalStorage();
       }
   });
   ```

2. **상태 히스토리**
   ```javascript
   const StateHistory = {
       history: [],
       push(state) {
           this.history.push({ ...state, timestamp: Date.now() });
       },
       undo() {
           if (this.history.length > 1) {
               this.history.pop();
               return this.history[this.history.length - 1];
           }
       }
   };
   ```

3. **서버로 상태 전송**
   ```javascript
   // 사용자 활동 추적
   async function saveUserActivity() {
       const state = StateManager.getState();
       await fetch('/api/analytics', {
           method: 'POST',
           body: JSON.stringify({
               view: state.currentView,
               duration: Date.now() - state.initialTimestamp
           })
       });
   }
   ```

---

## 9. 트러블슈팅

### 문제: 페이지 새로고침 시 상태 손실
**해결:** localStorage 사용
```javascript
StateManager.restoreFromLocalStorage();
```

### 문제: 서버 상태와 클라이언트 상태 불일치
**해결:** 주기적 동기화
```javascript
setInterval(async () => {
    await StateManager.fetchSystemState();
}, 60000); // 1분마다
```

### 문제: 상태 변경이 UI에 반영되지 않음
**해결:** 이벤트 리스너 활용
```javascript
window.addEventListener('stateChanged', updateUI);
```

---

## 10. 참고 자료

- **파일 위치:**
  - 서버: `src/main/java/com/trading/dashboard/controller/`
    - `DashboardController.java`
    - `MarketDataController.java`
  - 클라이언트: 
    - `src/main/resources/templates/dashboard.html`
    - `src/main/resources/static/js/dashboard.js`

- **API 엔드포인트:**
  - `GET /` - 대시보드 페이지 (Model 데이터 포함)
  - `GET /api/market/state` - 시스템 상태 조회
  - `GET /api/market/overview` - 시장 전체 현황
  - `WebSocket /ws` - 실시간 데이터 수신

---

## 요약

| 방법 | 용도 | 장점 | 단점 |
|------|------|------|------|
| **Model (Thymeleaf)** | 초기 설정 전달 | 즉시 사용, 빠름 | 정적 데이터만 |
| **REST API** | 동적 상태 조회 | 최신 데이터, 유연함 | 네트워크 비용 |
| **StateManager** | 클라이언트 상태 관리 | 중앙 집중, 일관성 | - |
| **WebSocket** | 실시간 업데이트 | 즉시성, 양방향 | 연결 관리 필요 |
| **LocalStorage** | 상태 영속화 | 새로고침 보존 | 용량 제한 |

페이지 상태 전달이 필요한 상황에 맞춰 적절한 방법을 선택하여 사용하세요!
